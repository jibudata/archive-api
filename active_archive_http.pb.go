// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.6.3
// - protoc             v4.23.4
// source: active_archive.proto

package v1

import (
	context "context"

	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationActiveArchiveAddMediaToPool = "/v1.ActiveArchive/AddMediaToPool"
const OperationActiveArchiveCreatePool = "/v1.ActiveArchive/CreatePool"
const OperationActiveArchiveDeletePool = "/v1.ActiveArchive/DeletePool"
const OperationActiveArchiveGetAsyncStatus = "/v1.ActiveArchive/GetAsyncStatus"
const OperationActiveArchiveGetDrivesInfo = "/v1.ActiveArchive/GetDrivesInfo"
const OperationActiveArchiveGetFileInfo = "/v1.ActiveArchive/GetFileInfo"
const OperationActiveArchiveGetMediaInfo = "/v1.ActiveArchive/GetMediaInfo"
const OperationActiveArchiveGetPoolsInfo = "/v1.ActiveArchive/GetPoolsInfo"
const OperationActiveArchiveListMediumInfo = "/v1.ActiveArchive/ListMediumInfo"
const OperationActiveArchiveMigrate = "/v1.ActiveArchive/Migrate"
const OperationActiveArchiveMigrateAsync = "/v1.ActiveArchive/MigrateAsync"
const OperationActiveArchiveRecall = "/v1.ActiveArchive/Recall"
const OperationActiveArchiveRecallAsync = "/v1.ActiveArchive/RecallAsync"
const OperationActiveArchiveRemoveMediaFromPool = "/v1.ActiveArchive/RemoveMediaFromPool"
const OperationActiveArchiveRetrieve = "/v1.ActiveArchive/Retrieve"

type ActiveArchiveHTTPServer interface {
	AddMediaToPool(context.Context, *PoolAddRequest) (*ReplyMessage, error)
	CreatePool(context.Context, *CreatePoolParams) (*ReplyMessage, error)
	DeletePool(context.Context, *LibraryManagerResourceKey) (*emptypb.Empty, error)
	GetAsyncStatus(context.Context, *AsyncStatusRequest) (*MigrationStatus, error)
	GetDrivesInfo(context.Context, *DefaultResourceRequest) (*DrivesInfo, error)
	GetFileInfo(context.Context, *FileInfoRequest) (*FileInfo, error)
	GetMediaInfo(context.Context, *LibraryManagerResourceKey) (*MediaInfoReply, error)
	GetPoolsInfo(context.Context, *DefaultResourceRequest) (*PoolsInfo, error)
	ListMediumInfo(context.Context, *DefaultResourceRequest) (*MediumInfo, error)
	Migrate(context.Context, *MigrateRequest) (*MigrationStatus, error)
	MigrateAsync(context.Context, *MigrateRequest) (*MigrationStatus, error)
	Recall(context.Context, *RecallRequest) (*MigrationStatus, error)
	RecallAsync(context.Context, *RecallRequest) (*MigrationStatus, error)
	RemoveMediaFromPool(context.Context, *PoolRemoveRequest) (*ReplyMessage, error)
	Retrieve(context.Context, *DefaultResourceRequest) (*ReplyMessage, error)
}

func RegisterActiveArchiveHTTPServer(s *http.Server, srv ActiveArchiveHTTPServer) {
	r := s.Route("/")
	r.GET("/api/v1/library_managers/{library_manager_name}/mediums", _ActiveArchive_ListMediumInfo0_HTTP_Handler(srv))
	r.GET("/api/v1/library_managers/{location_info.library_manager_name}/mediums/{name}", _ActiveArchive_GetMediaInfo0_HTTP_Handler(srv))
	r.GET("/api/v1/library_managers/{library_manager_name}/drives", _ActiveArchive_GetDrivesInfo0_HTTP_Handler(srv))
	r.GET("/api/v1/library_managers/{library_manager_name}/pools", _ActiveArchive_GetPoolsInfo0_HTTP_Handler(srv))
	r.POST("/api/v1/library_managers/{location_info.library_manager_name}/pools", _ActiveArchive_CreatePool0_HTTP_Handler(srv))
	r.DELETE("/api/v1/library_managers/{location_info.library_manager_name}/pools/{name}", _ActiveArchive_DeletePool0_HTTP_Handler(srv))
	r.POST("/api/v1/library_managers/{pool.location_info.library_manager_name}/pools/{pool.name}/actions/add_media", _ActiveArchive_AddMediaToPool0_HTTP_Handler(srv))
	r.POST("/api/v1/library_managers/{pool.location_info.library_manager_name}/pools/{pool.name}/actions/remove_media", _ActiveArchive_RemoveMediaFromPool0_HTTP_Handler(srv))
	r.POST("/api/v1/library_managers/{pool.location_info.library_manager_name}/actions/migrate", _ActiveArchive_Migrate0_HTTP_Handler(srv))
	r.POST("/api/v1/library_managers/{location_info.library_manager_name}/actions/recall", _ActiveArchive_Recall0_HTTP_Handler(srv))
	r.POST("/api/v1/library_managers/{library_manager_name}/actions/retrieve", _ActiveArchive_Retrieve0_HTTP_Handler(srv))
	r.POST("/api/v1/library_managers/{pool.location_info.library_manager_name}/actions/async_migrate", _ActiveArchive_MigrateAsync0_HTTP_Handler(srv))
	r.POST("/api/v1/library_managers/{location_info.library_manager_name}/actions/async_recall", _ActiveArchive_RecallAsync0_HTTP_Handler(srv))
	r.GET("/api/v1/library_managers/{location_info.library_manager_name}/async_status/{request_number}", _ActiveArchive_GetAsyncStatus0_HTTP_Handler(srv))
	r.GET("/api/v1/library_managers/{location_info.library_manager_name}/file_info/{file_name}", _ActiveArchive_GetFileInfo0_HTTP_Handler(srv))
}

func _ActiveArchive_ListMediumInfo0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DefaultResourceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveListMediumInfo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListMediumInfo(ctx, req.(*DefaultResourceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MediumInfo)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_GetMediaInfo0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LibraryManagerResourceKey
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveGetMediaInfo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetMediaInfo(ctx, req.(*LibraryManagerResourceKey))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MediaInfoReply)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_GetDrivesInfo0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DefaultResourceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveGetDrivesInfo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetDrivesInfo(ctx, req.(*DefaultResourceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DrivesInfo)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_GetPoolsInfo0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DefaultResourceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveGetPoolsInfo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetPoolsInfo(ctx, req.(*DefaultResourceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*PoolsInfo)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_CreatePool0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreatePoolParams
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveCreatePool)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreatePool(ctx, req.(*CreatePoolParams))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ReplyMessage)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_DeletePool0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LibraryManagerResourceKey
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveDeletePool)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeletePool(ctx, req.(*LibraryManagerResourceKey))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_AddMediaToPool0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PoolAddRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveAddMediaToPool)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddMediaToPool(ctx, req.(*PoolAddRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ReplyMessage)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_RemoveMediaFromPool0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PoolRemoveRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveRemoveMediaFromPool)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RemoveMediaFromPool(ctx, req.(*PoolRemoveRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ReplyMessage)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_Migrate0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MigrateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveMigrate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Migrate(ctx, req.(*MigrateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MigrationStatus)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_Recall0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RecallRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveRecall)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Recall(ctx, req.(*RecallRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MigrationStatus)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_Retrieve0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DefaultResourceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveRetrieve)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Retrieve(ctx, req.(*DefaultResourceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ReplyMessage)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_MigrateAsync0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MigrateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveMigrateAsync)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MigrateAsync(ctx, req.(*MigrateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MigrationStatus)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_RecallAsync0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RecallRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveRecallAsync)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RecallAsync(ctx, req.(*RecallRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MigrationStatus)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_GetAsyncStatus0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AsyncStatusRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveGetAsyncStatus)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetAsyncStatus(ctx, req.(*AsyncStatusRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MigrationStatus)
		return ctx.Result(200, reply)
	}
}

func _ActiveArchive_GetFileInfo0_HTTP_Handler(srv ActiveArchiveHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FileInfoRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationActiveArchiveGetFileInfo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFileInfo(ctx, req.(*FileInfoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FileInfo)
		return ctx.Result(200, reply)
	}
}

type ActiveArchiveHTTPClient interface {
	AddMediaToPool(ctx context.Context, req *PoolAddRequest, opts ...http.CallOption) (rsp *ReplyMessage, err error)
	CreatePool(ctx context.Context, req *CreatePoolParams, opts ...http.CallOption) (rsp *ReplyMessage, err error)
	DeletePool(ctx context.Context, req *LibraryManagerResourceKey, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	GetAsyncStatus(ctx context.Context, req *AsyncStatusRequest, opts ...http.CallOption) (rsp *MigrationStatus, err error)
	GetDrivesInfo(ctx context.Context, req *DefaultResourceRequest, opts ...http.CallOption) (rsp *DrivesInfo, err error)
	GetFileInfo(ctx context.Context, req *FileInfoRequest, opts ...http.CallOption) (rsp *FileInfo, err error)
	GetMediaInfo(ctx context.Context, req *LibraryManagerResourceKey, opts ...http.CallOption) (rsp *MediaInfoReply, err error)
	GetPoolsInfo(ctx context.Context, req *DefaultResourceRequest, opts ...http.CallOption) (rsp *PoolsInfo, err error)
	ListMediumInfo(ctx context.Context, req *DefaultResourceRequest, opts ...http.CallOption) (rsp *MediumInfo, err error)
	Migrate(ctx context.Context, req *MigrateRequest, opts ...http.CallOption) (rsp *MigrationStatus, err error)
	MigrateAsync(ctx context.Context, req *MigrateRequest, opts ...http.CallOption) (rsp *MigrationStatus, err error)
	Recall(ctx context.Context, req *RecallRequest, opts ...http.CallOption) (rsp *MigrationStatus, err error)
	RecallAsync(ctx context.Context, req *RecallRequest, opts ...http.CallOption) (rsp *MigrationStatus, err error)
	RemoveMediaFromPool(ctx context.Context, req *PoolRemoveRequest, opts ...http.CallOption) (rsp *ReplyMessage, err error)
	Retrieve(ctx context.Context, req *DefaultResourceRequest, opts ...http.CallOption) (rsp *ReplyMessage, err error)
}

type ActiveArchiveHTTPClientImpl struct {
	cc *http.Client
}

func NewActiveArchiveHTTPClient(client *http.Client) ActiveArchiveHTTPClient {
	return &ActiveArchiveHTTPClientImpl{client}
}

func (c *ActiveArchiveHTTPClientImpl) AddMediaToPool(ctx context.Context, in *PoolAddRequest, opts ...http.CallOption) (*ReplyMessage, error) {
	var out ReplyMessage
	pattern := "/api/v1/library_managers/{pool.location_info.library_manager_name}/pools/{pool.name}/actions/add_media"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationActiveArchiveAddMediaToPool))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) CreatePool(ctx context.Context, in *CreatePoolParams, opts ...http.CallOption) (*ReplyMessage, error) {
	var out ReplyMessage
	pattern := "/api/v1/library_managers/{location_info.library_manager_name}/pools"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationActiveArchiveCreatePool))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) DeletePool(ctx context.Context, in *LibraryManagerResourceKey, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/v1/library_managers/{location_info.library_manager_name}/pools/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationActiveArchiveDeletePool))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) GetAsyncStatus(ctx context.Context, in *AsyncStatusRequest, opts ...http.CallOption) (*MigrationStatus, error) {
	var out MigrationStatus
	pattern := "/api/v1/library_managers/{location_info.library_manager_name}/async_status/{request_number}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationActiveArchiveGetAsyncStatus))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) GetDrivesInfo(ctx context.Context, in *DefaultResourceRequest, opts ...http.CallOption) (*DrivesInfo, error) {
	var out DrivesInfo
	pattern := "/api/v1/library_managers/{library_manager_name}/drives"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationActiveArchiveGetDrivesInfo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) GetFileInfo(ctx context.Context, in *FileInfoRequest, opts ...http.CallOption) (*FileInfo, error) {
	var out FileInfo
	pattern := "/api/v1/library_managers/{location_info.library_manager_name}/file_info/{file_name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationActiveArchiveGetFileInfo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) GetMediaInfo(ctx context.Context, in *LibraryManagerResourceKey, opts ...http.CallOption) (*MediaInfoReply, error) {
	var out MediaInfoReply
	pattern := "/api/v1/library_managers/{location_info.library_manager_name}/mediums/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationActiveArchiveGetMediaInfo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) GetPoolsInfo(ctx context.Context, in *DefaultResourceRequest, opts ...http.CallOption) (*PoolsInfo, error) {
	var out PoolsInfo
	pattern := "/api/v1/library_managers/{library_manager_name}/pools"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationActiveArchiveGetPoolsInfo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) ListMediumInfo(ctx context.Context, in *DefaultResourceRequest, opts ...http.CallOption) (*MediumInfo, error) {
	var out MediumInfo
	pattern := "/api/v1/library_managers/{library_manager_name}/mediums"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationActiveArchiveListMediumInfo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) Migrate(ctx context.Context, in *MigrateRequest, opts ...http.CallOption) (*MigrationStatus, error) {
	var out MigrationStatus
	pattern := "/api/v1/library_managers/{pool.location_info.library_manager_name}/actions/migrate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationActiveArchiveMigrate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) MigrateAsync(ctx context.Context, in *MigrateRequest, opts ...http.CallOption) (*MigrationStatus, error) {
	var out MigrationStatus
	pattern := "/api/v1/library_managers/{pool.location_info.library_manager_name}/actions/async_migrate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationActiveArchiveMigrateAsync))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) Recall(ctx context.Context, in *RecallRequest, opts ...http.CallOption) (*MigrationStatus, error) {
	var out MigrationStatus
	pattern := "/api/v1/library_managers/{location_info.library_manager_name}/actions/recall"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationActiveArchiveRecall))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) RecallAsync(ctx context.Context, in *RecallRequest, opts ...http.CallOption) (*MigrationStatus, error) {
	var out MigrationStatus
	pattern := "/api/v1/library_managers/{location_info.library_manager_name}/actions/async_recall"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationActiveArchiveRecallAsync))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) RemoveMediaFromPool(ctx context.Context, in *PoolRemoveRequest, opts ...http.CallOption) (*ReplyMessage, error) {
	var out ReplyMessage
	pattern := "/api/v1/library_managers/{pool.location_info.library_manager_name}/pools/{pool.name}/actions/remove_media"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationActiveArchiveRemoveMediaFromPool))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ActiveArchiveHTTPClientImpl) Retrieve(ctx context.Context, in *DefaultResourceRequest, opts ...http.CallOption) (*ReplyMessage, error) {
	var out ReplyMessage
	pattern := "/api/v1/library_managers/{library_manager_name}/actions/retrieve"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationActiveArchiveRetrieve))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
